
exports.parseQuery = (query, values) => {
    const clauses = [' where ', ' group by ', ' order by ', ' limit ', ' having '];
    const config = {};
    config.aggregationArray = [];

    query = query.replace(/\n/g, ' ');
    let lowerCaseQuery = query.toLowerCase();
    if (lowerCaseQuery.startsWith('select')) {
        // database name, table name
        parseDBNameAndTableName(lowerCaseQuery, clauses, query, config);

        // where
        parseWhereClause(lowerCaseQuery, clauses, query, config, values);

        // property to select
        parsePropertiesSection(lowerCaseQuery, query, config);

        // group by || group by + count || count
        parseGroupBySection(lowerCaseQuery, clauses, query, config);

        // limit
        parseLimitSection(lowerCaseQuery, clauses, config, query);

        // order by
        parseOrderBySection(lowerCaseQuery, clauses, query, config);
    }
    return config;
}

function parseWhereClause(lowerCaseQuery, clauses, query, config, values) {
    let where = ' where ';
    if (lowerCaseQuery.includes(where)) {
        const startIndex = lowerCaseQuery.indexOf(where) + where.length;
        let endIndex = Math.min(...clauses.map(clause => lowerCaseQuery.indexOf(clause, startIndex)).filter(o => o !== -1), lowerCaseQuery.length);

        let conditions = query.substring(startIndex, endIndex)
            .replace(new RegExp(config.collectionNameAS + '.', 'g'), '')
            .split(" AND ")
            .map(o => o.trim())
            .map(o => o.includes(" OR ") ? o.split('OR ')[0] : o)
            .map(o => o.substring(1, o.length - 1));
        for (let i = 0; i < conditions.length; i++) {
            const condition = conditions[i];
            let property;
            if (condition.startsWith('`')) {
                property = condition.substring(1, condition.indexOf('`', 1));
            } else {
                property = condition.substring(0, condition.indexOf(' '));
            }
            if (condition.includes("NOT LIKE CONCAT('%', ?")) {
                config.aggregationArray.push({$match: {[property]: {$regex: new RegExp("^((?!" + values[i] + ").)*$")}}});
            } else if (condition.includes("LIKE CONCAT('%', ?")) {
                config.aggregationArray.push({$match: {[property]: {$regex: new RegExp(values[i])}}});
            } else if (condition.includes("IS NOT NULL")) {
                config.aggregationArray.push({$match: {[property]: {$ne: null}}});
            } else if (condition.includes("IS NULL")) {
                config.aggregationArray.push({$match: {[property]: {$eq: null}}});
            } else if (condition.includes(" = ")) {
                config.aggregationArray.push({$match: {[property]: values[i]}});
            } else if (condition.includes(" <> ")) {
                config.aggregationArray.push({$match: {[property]: values[i]}});
            }
        }
    }
}

function parseDBNameAndTableName(lowerCaseQuery, clauses, query, config) {
    if (lowerCaseQuery.includes('from')) {
        let startIndex = lowerCaseQuery.indexOf('from') + 'from'.length;

        let endIndex = Math.min(...clauses.map(clause => lowerCaseQuery.indexOf(clause, startIndex)).filter(o => o !== -1), lowerCaseQuery.length);

        let section = query.substring(startIndex, endIndex).trim().split(' AS ');

        config.collectionNameAS = section[1];
        let names = section[0].split('.');
        config.collectionName = names[1];
        config.dbName = names[0];
    }
}

function parsePropertiesSection(lowerCaseQuery, query, config) {
    let endIndex = lowerCaseQuery.indexOf('from');
    let properties = query.substring('select'.length + 1, endIndex).split(',').map(o => o.trim());
    properties.map(property => {
        if (property.startsWith(config.collectionNameAS)) {
            property = property.substring(config.collectionNameAS.length + 1);
        }
        if (config.properties === undefined) config.properties = [];
        let strings = [];

        if (property.startsWith('`')) {
            for (let i = 0; i < property.length; i++) {
                if (property.charAt(i) === '`') {
                    let string = '';
                    while (property.charAt(++i) !== '`') {
                        string += property.charAt(i);
                    }
                    i++;
                    strings.push(string);
                }
            }
        } else if (property.includes(' ')) {
            strings.push(...property.split(' '));
        }

        if (property.startsWith('count(')) {
            try {
                config.countAs = strings[1].substring(1, strings[1].length - 1);
            } catch (e) {
                config.countAs = 'count';
            }
        } else {
            config.properties.push({propName: strings[0], displayAs: strings[1]});
        }


        return property;
    })
}

function parseGroupBySection(lowerCaseQuery, clauses, query, config) {
    let groupBy = ' group by ';
    if (lowerCaseQuery.includes(groupBy)) {
        const startIndex = lowerCaseQuery.indexOf(groupBy) + groupBy.length;
        let endIndex = Math.min(...clauses.map(clause => lowerCaseQuery.indexOf(clause, startIndex)).filter(o => o !== -1), lowerCaseQuery.length);

        let properties = query.substring(startIndex, endIndex).split(',').map(o => parseInt(o.trim()) - 1);
        config.groupBy = {_id: {}};
        properties.forEach(index => {
            config.groupBy._id[config.properties[index].displayAs] = '$' + config.properties[index].propName;
        })

        if (config.countAs !== undefined) {
            config.groupBy[config.countAs] = {$sum: 1};
        }
        config.aggregationArray.push({$group: config.groupBy});
    } else if (config.countAs !== undefined) {
        config.aggregationArray.push({$count: config.countAs});
    }
}

function parseLimitSection(lowerCaseQuery, clauses, config, query) {
    let limit = ' limit ';
    if (lowerCaseQuery.includes(limit)) {
        const startIndex = lowerCaseQuery.indexOf(limit) + limit.length;
        let endIndex = Math.min(...clauses.map(clause => lowerCaseQuery.indexOf(clause, startIndex)).filter(o => o !== -1), lowerCaseQuery.length);
        config.limit = parseInt(query.substring(startIndex, endIndex).trim());
        config.aggregationArray.push({$limit: config.limit});
    }
}

function parseOrderBySection(lowerCaseQuery, clauses, query, config) {
    let orderBy = ' order by ';
    if (lowerCaseQuery.includes(orderBy)) {
        const startIndex = lowerCaseQuery.indexOf(orderBy) + orderBy.length;
        let endIndex = Math.min(...clauses.map(clause => lowerCaseQuery.indexOf(clause, startIndex)).filter(o => o !== -1), lowerCaseQuery.length);
        let orderString = query.substring(startIndex, endIndex).trim();
        const index = parseInt(orderString);
        const obj = {};
        if (config.properties.length < index && config.countAs !== undefined) {
            obj[config.countAs] = orderString.includes("DESC") ? -1 : 1;
        } else {
            obj["_id." + config.properties[index - 1].displayAs] = orderString.includes("DESC") ? -1 : 1;
        }
        config.aggregationArray.push({$sort: obj});

    }
}

