const MongoClient = require('mongodb').MongoClient;

const genericPool = require('generic-pool');
const {promisify} = require('util');
const BaseDriver = require('@cubejs-backend/query-orchestrator/driver/BaseDriver');
const crypto = require('crypto');
const queryParser = require('./QueryParser');

const GenericTypeToMySql = {
    string: 'varchar(255) CHARACTER SET utf8mb4',
    text: 'varchar(255) CHARACTER SET utf8mb4',
};

class MongoDBDriver extends BaseDriver {
    constructor(config) {
        super();
        // console.log(process.env);
        const {pool, ...restConfig} = config || {};
        this.config = {
            host: process.env.CUBEJS_DB_HOST,
            database: process.env.CUBEJS_DB_NAME,
            port: process.env.CUBEJS_DB_PORT,
            user: process.env.CUBEJS_DB_USER,
            password: process.env.CUBEJS_DB_PASS,
            ...restConfig
        };
        this.dbName = this.config.database;
        const url = 'mongodb://localhost:27017/' + this.dbName;
        const client = new MongoClient(url, {useUnifiedTopology: true});

        this.pool = genericPool.createPool({
            create: async () => {
                const connection = client.connect();
                return connection.then(client => client.db(this.dbName));
            },
            destroy: () => console.log('log it'),
            // promisify(connection.end.bind(connection))(),
            validate: async (connection) => {
                try {
                    // await connection.execute('SELECT 1');
                } catch (e) {
                    return false;
                }
                return true;
            },
        }, {
            min: 0,
            max: process.env.CUBEJS_DB_MAX_POOL && parseInt(process.env.CUBEJS_DB_MAX_POOL, 10) || 8,
            evictionRunIntervalMillis: 10000,
            softIdleTimeoutMillis: 30000,
            idleTimeoutMillis: 30000,
            testOnBorrow: true,
            acquireTimeoutMillis: 20000,
            ...pool,
        });
    }

    withConnection(fn) {
        const self = this;
        const connectionPromise = this.pool.acquire();

        let cancelled = false;
        const cancelObj = {};
        const promise = connectionPromise.then(async conn => {

            return fn(conn)
                .then(res => this.pool.release(conn).then(() => {
                    if (cancelled) {
                        throw new Error('Query cancelled');
                    }
                    return res;
                }))
                .catch((err) => this.pool.release(conn).then(() => {
                    if (cancelled) {
                        throw new Error('Query cancelled');
                    }
                    throw err;
                }));
        });
        promise.cancel = () => cancelObj.cancel();
        return promise;
    }

    async testConnection() {
        const db = await this.pool._factory.create();
        try {
            return await db.listCollections();
        } finally {
            // eslint-disable-next-line no-underscore-dangle
            await this.pool._factory.destroy(db);
        }
    }

    query(query, values) {

        console.log('query____', query, values);
        let config = queryParser.parseQuery(query, values);
        console.log(JSON.stringify(config.aggregationArray));

        return this.withConnection(db => db.collection(config.collectionName).aggregate(config.aggregationArray).toArray()
            .then(res => {
                const ans = [];
                for (let row of res) {
                    if ('_id' in row) {
                        const item = {...row._id};
                        item[config.countAs] = row[config.countAs];
                        ans.push(item)
                    } else {
                        ans.push(row)
                    }
                }
                console.log(ans);
                return ans;
            })
            .then(res => {
                console.log(res);
                return res;
            }));

        // return this.withConnection(db => this.setTimeZone(db)
        //     .then(() => db.execute(query, values))
        //     .then(res => res));
    }

    setTimeZone(db) {
        console.log('setTimeZone');

        return db.execute(`SET time_zone = '${this.config.storeTimezone || '+00:00'}'`, []);
    }

    async release() {
        console.log('release');

        await this.pool.drain();
        await this.pool.clear();
    }

    informationSchemaQuery() {
        console.log('informationSchemaQuery');

        return `${super.informationSchemaQuery()} AND columns.table_schema = '${this.config.database}'`;
    }

    quoteIdentifier(identifier) {
        console.log('quoteIdentifier');

        return `\`${identifier}\``;
    }

    fromGenericType(columnType) {
        console.log('fromGenericType');

        return GenericTypeToMySql[columnType] || super.fromGenericType(columnType);
    }

    loadPreAggregationIntoTable(preAggregationTableName, loadSql, params, tx) {
        console.log('loadPreAggregationIntoTable');

        if (this.config.loadPreAggregationWithoutMetaLock) {
            return this.cancelCombinator(async saveCancelFn => {
                await saveCancelFn(this.query(`${loadSql} LIMIT 0`, params));
                await saveCancelFn(this.query(loadSql.replace(/^CREATE TABLE (\S+) AS/i, 'INSERT INTO $1'), params));
            });
        }
        return super.loadPreAggregationIntoTable(preAggregationTableName, loadSql, params, tx);
    }

    async downloadQueryResults(query, values) {
        console.log('downloadQueryResults');

        if (!this.config.database) {
            throw new Error(`Default database should be defined to be used for temporary tables during query results downloads`);
        }
        const tableName = crypto.randomBytes(10).toString('hex');
        const columns = await this.withConnection(async db => {
            await this.setTimeZone(db);
            await db.execute(`CREATE TEMPORARY TABLE \`${this.config.database}\`.t_${tableName} AS ${query} LIMIT 0`, values);
            const result = await db.execute(`DESCRIBE \`${this.config.database}\`.t_${tableName}`);
            await db.execute(`DROP TEMPORARY TABLE \`${this.config.database}\`.t_${tableName}`);
            return result;
        });

        const types = columns.map(c => ({name: c.Field, type: this.toGenericType(c.Type)}));

        return {
            rows: await this.query(query, values),
            types,
        };
    }

    toColumnValue(value, genericType) {
        console.log('toColumnValue');

        if (genericType === 'timestamp' && typeof value === 'string') {
            return value && value.replace('Z', '');
        }
        if (genericType === 'boolean' && typeof value === 'string') {
            if (value.toLowerCase() === 'true') {
                return true;
            }
            if (value.toLowerCase() === 'false') {
                return false;
            }
        }
        return super.toColumnValue(value, genericType);
    }

    async uploadTable(table, columns, tableData) {
        console.log('uploadTable');

        if (!tableData.rows) {
            throw new Error(`${this.constructor} driver supports only rows upload`);
        }
        await this.createTable(table, columns);
        try {
            const batchSize = 1000; // TODO make dynamic?
            for (let j = 0; j < Math.ceil(tableData.rows.length / batchSize); j++) {
                const currentBatchSize = Math.min(tableData.rows.length - j * batchSize, batchSize);
                const indexArray = Array.from({length: currentBatchSize}, (v, i) => i);
                const valueParamPlaceholders =
                    indexArray.map(i => `(${columns.map((c, paramIndex) => this.param(paramIndex + i * columns.length)).join(', ')})`).join(', ');
                const params = indexArray.map(i => columns
                    .map(c => this.toColumnValue(tableData.rows[i + j * batchSize][c.name], c.type)))
                    .reduce((a, b) => a.concat(b), []);

                await this.query(
                    `INSERT INTO ${table}
        (${columns.map(c => this.quoteIdentifier(c.name)).join(', ')})
        VALUES ${valueParamPlaceholders}`,
                    params,
                );
            }
        } catch (e) {
            await this.dropTable(table);
            throw e;
        }
    }


    async tablesSchema() {
        const db = await this.pool._factory.create();
        return Promise.all([
            db.listCollections()
                .map(o => o.name)
                .toArray(),
            db.listCollections()
                .map(o => db.collection(o.name).findOne())
                .toArray()
                .then(arr => Promise.all(arr))
        ]).then((res) => {
            const names = res[0];
            const data = res[1];
            const obj = {};
            for (let i = 0; i < names.length; i++) {
                const property = [];
                for (const p in data[i]) {
                    property.push({name: p, type: typeof data[i][p], attributes: []})
                }
                obj[names[i]] = property;
            }
            const ans = {}
            ans[this.dbName] = obj;
            return ans;
        })
            // .then(JSON.stringify)
            // .then(console.log)
    }
}

module.exports = MongoDBDriver;


new MongoDBDriver();