import Dockerode from "dockerode";
import { Duration } from "node-duration";
import { BoundPorts } from "./bound-ports";
import { Container, Id } from "./container";
import { Host } from "./docker-client-factory";
import { RepoTag } from "./repo-tag";
export declare type Command = string;
export declare type ContainerName = string;
export declare type NetworkMode = string;
export declare type ExitCode = number;
export declare type EnvKey = string;
export declare type EnvValue = string;
export declare type Env = {
    [key in EnvKey]: EnvValue;
};
export declare type Dir = string;
export declare type TmpFs = {
    [dir in Dir]: Dir;
};
export declare type HealthCheck = {
    test: string;
    interval?: Duration;
    timeout?: Duration;
    retries?: number;
    startPeriod?: Duration;
};
export declare type BuildContext = string;
export declare type BuildArgs = {
    [key in EnvKey]: EnvValue;
};
export declare type StreamOutput = string;
export declare type ExecResult = {
    output: StreamOutput;
    exitCode: ExitCode;
};
export declare type BindMode = "rw" | "ro";
export declare type BindMount = {
    source: Dir;
    target: Dir;
    bindMode: BindMode;
};
export declare type AuthConfig = {
    username: string;
    password: string;
    serveraddress: string;
    email?: string;
};
export declare type LogConfig = {
    logDriver: string;
    logOpts?: object;
};
declare type CreateOptions = {
    repoTag: RepoTag;
    env: Env;
    cmd: Command[];
    bindMounts: BindMount[];
    tmpFs: TmpFs;
    boundPorts: BoundPorts;
    name?: ContainerName;
    networkMode?: NetworkMode;
    healthCheck?: HealthCheck;
    useDefaultLogDriver: boolean;
    privilegedMode: boolean;
};
export declare type CreateNetworkOptions = {
    name: string;
    driver: "bridge" | "overlay" | string;
    checkDuplicate: boolean;
    internal: boolean;
    attachable: boolean;
    ingress: boolean;
    enableIPv6: boolean;
    labels?: {
        [key: string]: string;
    };
    options?: {
        [key: string]: string;
    };
};
export interface DockerClient {
    pull(repoTag: RepoTag, authConfig?: AuthConfig): Promise<void>;
    create(options: CreateOptions): Promise<Container>;
    createNetwork(options: CreateNetworkOptions): Promise<string>;
    removeNetwork(id: string): Promise<void>;
    start(container: Container): Promise<void>;
    exec(container: Container, command: Command[]): Promise<ExecResult>;
    buildImage(repoTag: RepoTag, context: BuildContext, dockerfileName: string, buildArgs: BuildArgs): Promise<void>;
    fetchRepoTags(): Promise<RepoTag[]>;
    getHost(): Host;
    listContainers(): Promise<Dockerode.ContainerInfo[]>;
    getContainer(id: Id): Promise<Container>;
}
export declare class DockerodeClient implements DockerClient {
    private readonly host;
    private readonly dockerode;
    constructor(host: Host, dockerode: Dockerode);
    pull(repoTag: RepoTag, authConfig?: AuthConfig): Promise<void>;
    create(options: CreateOptions): Promise<Container>;
    createNetwork(options: CreateNetworkOptions): Promise<string>;
    removeNetwork(id: string): Promise<void>;
    start(container: Container): Promise<void>;
    exec(container: Container, command: Command[]): Promise<ExecResult>;
    buildImage(repoTag: RepoTag, context: BuildContext, dockerfileName: string, buildArgs: BuildArgs): Promise<void>;
    fetchRepoTags(): Promise<RepoTag[]>;
    listContainers(): Promise<Dockerode.ContainerInfo[]>;
    getContainer(id: Id): Promise<Container>;
    getHost(): Host;
    private isDanglingImage;
    private getEnv;
    private getHealthCheck;
    private toNanos;
    private getExposedPorts;
    private getPortBindings;
    private getBindMounts;
    private getLogConfig;
}
export {};
